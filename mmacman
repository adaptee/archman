#!/usr/bin/python

import os, sys
from time import time as utime
from random import choice, randint
from optparse import OptionParser, OptionGroup

from pyalpmm import Session, PyALPMMConfiguration, Events, System
from pyalpmm.transaction import SyncTransaction, RemoveTransaction, \
     UpgradeTransaction, AURTransaction, DatabaseUpdateTransaction, \
     SysUpgradeTransaction
from pyalpmm.tools import AskUser, CriticalError, FancyPackage, ProgressBar, \
     UserError, FancySize
from pyalpmm.pbuilder import PackageBuilder, BuildError
from pyalpmm.database import DatabaseError
from pyalpmm.item import PackageItem

import pyalpmm_raw as p

# debug WingIDE
#import wingdbstub

class MMacmanEvents(Events):
    progressbar_sleep = property(lambda s: 1/float(randint(5,20)))
    def __init__(self):
        super(MMacmanEvents, self).__init__()
        self.progress_obj = None
        self.processed_pkgs = None
        self.active_pkg = None
        self.last_pkg = None
        self.line_dirty = False
        self.last_total_download = None

    def DatabaseUpToDate(self, **kw):
        print "[i] Database up to date: {0}".format(kw["repo"])

    def DatabaseUpdated(self, **kw):
        if self.line_dirty:
            self.line_dirty = False
            sys.stdout.write("\r{0}\n".format(self.progress_obj.step_to_end()))
            sys.stdout.flush()

        print "[+] Database updated: {0}".format(kw["repo"])

    def DatabaseUpdateError(self, **kw):
        print "[e] Database could not be updated: {0}".format(kw["repo"])

    def StartResolvingDependencies(self):
        print "[i] Resolving Dependencies..."

    def StartCheckingInterConflicts(self):
        print "[i] Checking Inter-Conflicts..."

    def StartRetrievingPackages(self, **kw):
        print "[+] Retrieving from {0}".format(kw["repo"])

    def StartUpgradingPackage(self, **kw):
        if self.line_dirty:
            sys.stdout.write("\n")
            sys.stdout.flush()
            self.line_dirty = False
        self.progress_obj = None
        self.active_pkg = kw["pkg"]

    def StartRemovingPackage(self, **kw):
        if self.line_dirty:
            sys.stdout.write("\n")
            sys.stdout.flush()
            self.line_dirty = False
        self.progress_obj = None
        self.active_pkg = kw["pkg"]

    def StartInstallingPackage(self, **kw):
        if self.line_dirty:
            sys.stdout.write("\n")
            sys.stdout.flush()
            self.line_dirty = False
        self.progress_obj = None
        self.active_pkg = kw["pkg"]

    def DoneInstallingPackage(self, **kw):
        sys.stdout.write("\n")
        sys.stdout.flush()

    def DoneRemovingPackage(self, **kw):
        # pkg
        sys.stdout.write("\n")
        sys.stdout.flush()

    def DoneUpgradingPackage(self, **kw):
        sys.stdout.write("\n")
        sys.stdout.flush()

    def StartCheckingPackageIntegrity(self):
        sys.stdout.write("[+] Checking package integrity...\r\n")
        sys.stdout.flush()

    def StartCheckingFileConflicts(self):
        self.progress_obj = None
        pass

    def StartBuild(self, **kw):
        print "[+] Starting build: {0.name}-{0.version}".format(kw["pkg"])

    def ReInstallingPackage(self, **kw):
        print "[i] Reinstalling package: {0.name}-{0.version}".format(kw["pkg"])

    def _progress(self, operation, kw):
        if self.progress_obj is None:
            desc = "[i] {0} {1}".format(operation, kw["pkgname"])
            self.progress_obj = ProgressBar(100, desc)

        sys.stdout.write(self.progress_obj.step_to(kw["percent"]) + "\r")
        sys.stdout.flush()

        self.line_dirty = True

    def ProgressDownload(self, **kw):
        fn = filename = kw["filename"]

        if self.progress_obj is None:
            self.active_pkg = "" if fn.endswith(".db.tar.gz") \
                else PackageItem(None)
        print "active: {0} last: {1}".format(self.active_pkg, self.last_pkg)
        self.last_pkg = self.active_pkg

        # PackageItem means package download
        if isinstance(self.active_pkg, PackageItem):
            for name, pkg in self.processed_pkgs.items():
                if fn.find(name) == 0:
                    self.active_pkg = pkg
            size = int(pkg.size.raw)
            label = "[D] {0.name}-{0.version}".format(self.active_pkg)
        # str means database file download
        elif isinstance(self.active_pkg, str):
            self.active_pkg = fn
            size = None
            label = "[D] {0}".format(fn)

        if self.progress_obj is None:
            self.progress_obj = ProgressBar(size, label)

        sys.stdout.write((self.progress_obj.step_to(kw["transfered"]) \
                          if self.progress_obj.endvalue \
                          else self.progress_obj.step_to(7)) + "\r")
        sys.stdout.flush()

        self.line_dirty = True
        if (self.progress_obj is not None and \
            self.progress_obj.percent == 100) or \
           self.active_pkg != self.last_pkg:
            self.progress_obj = None
            sys.stdout.write("\n")
            sys.stdout.flush()

    def ProgressDownloadTotal(self, **kw):
        if self.last_total_download is None:
            sys.stdout.write("\n")
            sys.stdout.flush()

        #self.progress_obj = None
        self.processed_pkgs = dict((p.name, p) for p in kw["pkgs"])

    def ProgressInstall(self, **kw):
        self._progress("Installing:", kw)

    def ProgressRemove(self, **kw):
        self._progress("Removing:", kw)

    def ProgressUpgrade(self, **kw):
        self._progress("Upgrading:", kw)

    def ProgressConflict(self, **kw):
        self._progress("Checking File Conflicts:", kw)

    def ProcessingPackages(self, **kw):
        total = 0
        print "[i] Processing Packages:"
        for pkg in kw["pkgs"]:
            total += pkg.isize.raw
            show_size = ("{0.size}" if pkg.isize == pkg.size else \
                         "{0.size} / {0.isize}").format(pkg)
            name = "    {0.name}-{0.version}".format(pkg)
            print "{0:30}{1}".format(name, show_size)

        print
        print "[i]    Total size: {0}".format(FancySize(total))
        if AskUser("[?] Really continue (y/n)? ").answer == "n":
            print "[e] ok, stopping operation"
            raise UserError("User aborted operation!")


parser = OptionParser()
group = OptionGroup(parser, "General Options",
                    "Can be used standalone and in combination with any other options")
group.add_option("-y", "--update", dest="update", action="store_true",
                  help="Update all Databases (usable standalone, or in combination with everything)")
group.add_option("-c", "--configfile", dest="configfile", metavar="FILE",
                  help="use given file as a config file")
parser.add_option_group(group)


group = OptionGroup(parser, "Additional flags", "To be used in combination with other actions")
group.add_option("-f", "--force", dest="force", action="store_true",
                  help="force action")
group.add_option("-d", "--nodeps", dest="nodeps", action="store_true",
                  help="ignore dependencies")
group.add_option("-w", "--downloadonly", dest="download_only", action="store_true",
                  help="only download packages")
group.add_option("-i", "--info", dest="info", action="store_true",
                  help="Get info for some package. With -Q local and with -S from sync repo")
parser.add_option_group(group)

group = OptionGroup(parser, "Sync Actions",
                    "-S activates the sync actions")
group.add_option("-S", "--sync", dest="sync", action="store_true",
                  help="Synchronise package")
group.add_option("-u", "--sysupgrade", dest="sysupgrade", action="store_true",
                  help="Perform a global system upgrade")
group.add_option("-s", "--search", dest="search", action="store_true",
                  help="Search package in SyncDatabases")
parser.add_option_group(group)

group = OptionGroup(parser, "Upgrade Actions",
                    "-U activates the upgrade actions")
group.add_option("-U", "--upgrade", dest="upgrade", action="store_true",
                  help="Upgrade package")
parser.add_option_group(group)

group = OptionGroup(parser, "Query Actions",
                    "-Q activates the Query Actions")
group.add_option("-Q", "--query", dest="query", action="store_true",
                  help="List all local packages")
group.add_option("", "--aur", dest="aur", action="store_true",
                 help="While listing all packages, check which ones are from AUR")
group.add_option("", "--loner", dest="loner", action="store_true",
                 help="Search for 'lonely' packages, means not explicitly " \
                      "installed packages, which are not required by any " \
                      "other installed package")
group.add_option("", "--filesystem", dest="filesystem", action="store_true",
                 help="Search the entire filesystem for not package-managed " \
                      "files")
group.add_option("-F", "--files", dest="show_files", action="store_true",
                 help="List of all files in the given package")
group.add_option("-o", "--owns", dest="owns", action="store_true",
                 help="Look for package that contains the given file/dir/path")

parser.add_option_group(group)

group = OptionGroup(parser, "Remove Actions",
                    "-R activates the Remove Actions")
group.add_option("-R", "--remove", dest="remove", action="store_true",
                  help="Remove the given packages from the system")
group.add_option("", "--no-recu", dest="no_recursive_remove", action="store_true",
                  help="Do not recursivly remove unneeded dependencies on remove")
parser.add_option_group(group)

group = OptionGroup(parser, "Build Actions",
                    "-B activates the Build Actions")
group.add_option("-B", "--build", dest="build", action="store_true",
                  help="Build the given packages either from abs or from aur")
group.add_option("-I", "--install", dest="build_install", action="store_true",
                  help="Install the built package")
group.add_option("-e", "--edit", dest="build_edit", action="store_true",
                  help="Edit the PKGBUILD before building")
group.add_option("", "--no-cleanup", dest="build_no_cleanup", action="store_true",
                  help="Don't cleanup (delete) the build dir before")
group.add_option("", "--no-prepare", dest="build_no_prepare", action="store_true",
                  help="Don't prepare (download scripts and sources) the build")
parser.add_option_group(group)


group = OptionGroup(parser, "Evil Options",
                    "only --args are used in the evil opts")
group.add_option("", "--clear-pkg-cache", dest="cpc", action="store_true",
                  help="cleanup the package cache directory")
parser.add_option_group(group)

(options, args) = parser.parse_args()

events = MMacmanEvents()
config = PyALPMMConfiguration(events, options.configfile, cmd_args=options)

# uncomment this to enable logging to /tmp/alpm.log (or set events.logfile manually)
# events.logfile = config.logfile

session = Session(config)

# global exception catcher func callback
def exc_cb(type_, val, trace):
    if not issubclass(type_, CriticalError):
        raise type_(val)

    print "[e] A {0} occured:".format(type_.__name__)
    print "[e] {0}".format(val)

def sig_cb(signal, frame):
    print "[e] Got Signal: {0}".format(signal)
    print "[e] {0}".format(frame)
    print "cannot cancel, wait till end"

system = System(session, global_exc_cb=exc_cb, global_sig_cb=sig_cb)
#system = System(session)

if options.cpc:
    print "[i] evil option detected"
    print "[i] deleting cache dirs"
    import shutil
    for path in config.cachedirs:
        shutil.rmtree(path, True)
        print "[!] deleted: {0}".format(path)

if options.cpc: # or ...
    print "[i] always exiting after an evil option"
    sys.exit()

#print "[i] You have set the following commandline options:"
if options.force:
    print "[i]     Forced transaction (-f)"
if options.nodeps:
    print "[i]     Ignoring dependencies (-d)"
if options.download_only:
    print "[i]     Download packages only (-w)"
if options.build_install:
    print "[i]     Installing the freshly built package (-I)"
if options.build_edit:
    print "[i]     Edit the PKGBUILD before makepkg (-e)"
if options.build_no_cleanup:
    print "[i]     Don't cleanup build {0.build_dir} (--no-cleanup)". \
          format(config)
if options.build_no_prepare:
    print "[i]     Do not prepare PackageBuilder (--no-prepare)"
if options.no_recursive_remove:
    print "[i]     Do not recursivly remove dependencies on remove (--no-recu)"


if options.update:
    system.update_databases()

# check for all affected options, if there is at least one positional argument
if len(args) == 0:
    if (options.query and options.owns) or (options.query and options.info):
        print "[e] you have to pass one argument to issue a query!"
        sys.exit()
    elif options.build:
        print "[e] you have to pass the name of the package you want to build!"
        sys.exit()
    elif options.upgrade or options.remove or \
         (options.sync and not options.sysupgrade):
        print "[e] you have to pass at least one package name to process!"
        sys.exit()

if options.sync and options.search:
    result = system.search_packages(args[0])
    for pkg in result:
        print "[P] {0.repo}/{0.name}-{0.version} ".format(pkg)
        print "       {0.desc}".format(pkg)

elif options.query and options.owns:
    print "[+] looking for the owner of: '{0}'".format(args[0])
    filename = args[0].startswith("/") and args[0][1:] or args[0]
    pkg = system.owner_of_file(filename)
    if pkg is None:
        print ("[-] {0} was not found in any known package, \
               only the local repository can be searched.".format(args[0]))
        sys.exit()

    print "[+] '{0}' was found in the package: {1.name}-{1.version}".\
          format(args[0], pkg)

elif options.query and options.info:
    pkg = session.db_man.get_local_package(args[0])
    if pkg is None:
        print "[-] Sorry, haven't found a match for: {0}".format(args[0])
        sys.exit()

    if options.info:
        if options.show_files:
            print "[+] Showing filelist of: {0}".format(args[0])
            for fn in pkg.files:
                print "[i] {0}".format(fn)
        else:
            print FancyPackage(pkg)

elif options.query and options.loner:
    print "[+] Starting 'lonely' package search"

    loners = system.get_unneeded_packages()
    # showing loners
    if len(loners) == 0:
        print "[+] There were no loners found on your system!"
    else:
        print "[+] I have found the following loners on your system:"
        for pkg in loners:
            print "[i] {0.name}-{0.version}".format(pkg)

elif options.query and options.filesystem:
    db = session.db_man

    # creating full file-map (could take some mem)
    fm = file_map = {}
    for pkg in db.get_local_packages():
        for fn in pkg.files:
            fm["/" + fn] = pkg

    # checking filesystem against map
    searchdirs = ["/usr", "/etc", "/var", "/boot", "/opt", "/bin", "/sbin", \
                  "/lib"]
    exclude = ["/usr/lib/python2.6"]
    orphans = []

    def callback(arg, path, content):
        for fn in content:
            fp = fullpath = os.path.join(path, fn)
            if fp in exclude:
                content.remove(fn)
                continue
            if os.path.isdir(fp):
                continue
            if fp not in fm:
                orphans.append(fp)

    for path in searchdirs:
        os.path.walk("/usr", callback, None)

    print "[+] Found {0} orphans:".format(len(orphans))
    for orphan in orphans:
        print "[i] {0}".format(orphan)

elif options.query:
    db = session.db_man
    print "[+] Listing all installed packages: "
    print "[h] (left [X] stands for AUR, the right one for beeing " \
          "explicitly installed)"
    counter, manually_installed = 0, 0
    aur_pkgs = set()
    for pkg in db.get_local_packages():
        counter += 1
        in_aur, manually_installed = 0, 0
        if pkg.reason == p.PM_PKG_REASON_EXPLICIT:
            manually_installed += 1
        if options.aur and not db.get_package(pkg.name, repos=config.repos):
            aur_pkgs.add(pkg)

        pkg_opts = "[{0}] [{1}]".format(
            ("x" if pkg in aur_pkgs else " "),
            ("x" if pkg.reason == p.PM_PKG_REASON_EXPLICIT else " ")
        )
        print " {0} {1}-{2}".format(pkg_opts, pkg.name, pkg.version)


    print "[i] {0} packages installed!".format(counter)
    if options.aur:
        regularpkgs = counter - len(aur_pkgs)
        print "[i] {0} packages from 'regular' repositories".format(regularpkgs)
        print "[i] {0} packages from other repositories".format(len(aur_pkgs))
        print "[i] Listing packages from third-party repositories now:"
        for pkg in aur_pkgs:
            print "  - {0.name}-{0.version}".format(pkg)

elif options.upgrade:
    system.upgrade_packages(targets=args)
elif options.remove:
    system.remove_packages(targets=args, recursive=options.no_recursive_remove)
elif options.build:
    system.build_packages(targets=args)
elif options.sync and options.sysupgrade:
    system.sys_upgrade()
elif options.sync:
    system.sync_packages(targets=args)
else:
    if not options.update:
        parser.print_help()
